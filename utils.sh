#!/bin/sh

# function to mount bkpfs
function mount_bkpfs {
  maxversions=$1
  mount_path=$2
  writefrequency=$3

  # create the mount point if doesn't exist
  if [ ! -d "$mount_path" ]; then
    mkdir -p "$mount_path"test
  fi

  # mount bkpfs
  mount -t bkpfs -o maxver="$maxversions" -o writefrequency="$writefrequency" "$mount_path"test "$mount_path"
  retval=$?
  if [ $retval -ne 0 ]; then
    echo $retval
  else
    echo 0
  fi
}

# unmount bkpfs
function unmount_bkpfs {
  mount_point=$1
  umount "$mount_point"
  retval=$?
  if [ $retval -ne 0 ]; then
    echo $retval
  else
    echo 0
  fi
}

# create the backup files
function create {
    number_of_backups=$1
    filename=$2
    mount_path=$3
    index=1
    content=""

    # the idea is to concat all the inputs without a newline to make it easier for testing 
    while [ $index -le $number_of_backups ]; do
      if [ -f "$mount_path$filename" ]; then
        content=$(cat "$mount_path$filename")
      fi
      content="$content$index"
      echo $content > "$mount_path$filename"
      index=`expr $index + 1`
    done;
}

# remove any remnants of the test case we just ran
function cleanup {
   index=1
   number_of_backups=$1
   filename=$2
   mount_path=$3
   
    while [ $index -le $number_of_backups ]; do
        backup_filename="$filename.bckp.""$index"
	      if [ -f "$mount_path$backup_filename" ]; then
	        rm -f "$mount_path$backup_filename";
	      fi
	      index=`expr $index + 1`
    done;
  
   if [ -f "$mount_path$filename" ]; then
	  rm -f "$mount_path$filename"
   fi
}

# get the output of listing which matches the output generated by the user program
function get_versions_list {
  local versions=("$@")
  local expected=""
  
  for i in ${!versions[@]}; do
    line=$(printf "Backup version %d : %s.bckp.%d" $((${i}+1)) "$filename" ${versions[$i]})
    expected="$expected""$line"
    if [ $(($i + 1)) -lt ${#versions[@]} ]; then
      expected="$expected"" "	
    fi
  done
 
  echo "$expected"
}

# intialize the test
function init_test {
  mount_path=$1
  maxversions=$2
  write_frequency=$3
  filename=$4
  number_of_backups=$5

  status=-1
  # clean any previous run and build the user program
  make clean
  make

  retval=$?

  if [ $retval -ne 0 ]; then
    exit $retval
  fi

  if [ -z $maxversions ]; then
    maxversions=5
  fi

  if [ -z $filename ]; then
    filename=test_file.txt
  fi

  if [ -z $mount_path ]; then
    mount_path=/mnt/bkpfs/
  fi

  if [ -z $writefrequency ]; then
    writefrequency=1
  fi

  if [ -z $number_of_backups ]; then
     number_of_backups=$maxversions
  fi

  #cleanup any old master file or backups related to it
  cleanup $number_of_backups $filename $mount_path
  
  # unmount bkpfs if already mounted
  if mountpoint -q $mount_path
        then
          status=$(unmount_bkpfs "$mount_path")
          if [ $status -ne 0 ]; then
           exit -1
          fi
  fi

  # now finally mount the file system
  status=$(mount_bkpfs $maxversions $mount_path $writefrequency)

  if [ $status -ne 0 ]; then
    exit -1
  fi

  #Now create the backup files
  create $number_of_backups $filename $mount_path

}

# teardown procedure; cleanup master and backup files, build files and finally unmount the file system
function teardown_test {
  filename=$1
  mount_path=$2
  number_of_backups=$3
  status=-1

   if [ -z $number_of_backups ]; then
    number_of_backups=5
  fi

  if [ -z $filename ]; then
    filename=test_file.txt
  fi

  if [ -z $mount_path ]; then
    mount_path=/mnt/bkpfs/
  fi


  cleanup $number_of_backups $filename $mount_path
  
  make clean

  # unmount bkpfs if already mounted
  if mountpoint -q $mount_path
      then
        status=$(unmount_bkpfs "$mount_path")
        if [ $status -ne 0 ]; then
          exit -1
        fi
  fi

}
